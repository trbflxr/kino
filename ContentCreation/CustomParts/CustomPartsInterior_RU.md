# Создание кастомного интерьера

## Подготовка и создание пака

Если вы уже создали пак и хотите добавить в него детали, то этот шаг можно пропустить.

Не нужно создавать для каждой детали отдельный пак, группируйте их по типам, производителям и т.д.

Для создания пака воспользуйтесь [этим гайдом](CustomParts_RU.md).

# Создание модели

> [!NOTE]
> Модель можно создать в любом удобном для вас 3D софте. В примере будет использован `Blender`.

> [!IMPORTANT]
> В ContentSDK есть примеры салона с исходниками в папке `CarParts\Examples\CustomInterior`. Рекомендуем ознакомится с ними.

## Подготовка

Перед работой рекомендуется сдампить модель **стокового** интерьера, для этого выполните следующие действия:

1. перейдите в меню дампа авто: `Tools -> Car dumper`
2. сдампите модель нажав `Dump model`

> [!IMPORTANT]
> Обязательно сдампите `PartRoots`, с ними будет гораздо проще установить объекты в нужные позиции.

![parts_car_dumper](../Images/CarParts/parts_car_dumper.png)

## Создание

Загрузите сдампленную модель в 3D редактор.

![parts_interior_model](../Images/CarParts/Interior/parts_interior_model.png)

Вы можете модифицировать стоковый интерьер или создать новый, основываясь на его форме и размерах.

### Создание рутов для деталей интерьера

Для правильной работы **необходимо** создать руты для деталей салона. Без этих рутов на авто невозможно будет установить сидения, рули, шифтеры и т.д.

Если вы сдампили модель и руты, то у вас в иерархии будет несколько объектов с именем начинающемся на `root_interior_` - это стоковые руты для деталей.

> [!IMPORTANT]
> Обратите внимание, что рут должен представлять собой пустой объект (`Plain Axes` в случае с Blender)

Для создания рута выполните следующие шаги:
1. Выберите один из объектов `root_interior_`
2. Перейдите в Edit Mode нажав `Tab`
3. Установите курсор в его центр `Shift + S -> Cursor to selected`
4. Перейдите в Object Mode нажав `Tab`
5. После чего создайте `Plain Axes` через меню `Add -> Empty -> Plain Axes`
6. Назовите рут так же как назывался изначальный объект, но убрав `root_interior_` в начале и добавив `_root` в конце (пример: `root_interior_shifter` -> `shifter_root`)

Выполните действия указанные выше для всех рутов (2 сидения, ручник, шифтер, руль). Опционально добавьте руты для крепления ремней.

### Импорт моделей в Unity

Для импорта моделей в Unity вы можете перетащить нужные файлы в окно `Project` или поместить их туда вручную, через проводник.

После импорта выберите нужную модель и в окне `Inspector` перейдите на вкладку `Materials`.

Если кнопки `Extract Textures` и `Extract Materials` серые и не кликабельные, то ничего делать не нужно.

Если же они активны, то сперва извлеките текстуры, а после материалы.

![parts_unity_import_model](../Images/CarParts/parts_unity_import_model.png)

Так же вы можете настроить [интеграцию с Blender](../Tools/BlenderIntegration_RU.md), для большего удобства импорта моделей.

> [!IMPORTANT]
> Обязательно выберите импортированную модель и включите опцию `Read/Write Enabled` окне инспектора, во вкладке `Model`.

![parts_model_import_read_write](../Images/CarParts/parts_model_import_read_write.png)

### Подготовка префаба

После того как вы импортировали и подготовили модель из неё нужно создать префаб для дальнейшей настройки.

Вы можете это сделать любым удобным для вас способом, или воспользовавшись инструкцией:

![parts_create_prefab_short](../Images/CarParts/parts_create_prefab_short.gif)

### Настройка материалов салона

Вы можете использовать любые материалы и шейдеры для салона.
Однако если вы хотите добавить подсветку при включении зажигания вам нужно будет создать и настроить материал с шейдером `CarInterior` и назначить его для нужных объектов.

![parts_interior_emissive_material](../Images/CarParts/Interior/parts_interior_emissive_material.png)

Параметры шейдера `CarInterior`:
* `BaseMap` - Это обычная diffusion текстура.
* `NormalMap` - Карта нормалей.
* `ColormaskMap` - Маска для указания каналов дополнительной покраски объекта.
* `R_TintColor` - Цвет в **Красном (R)** канале маски. 
* `G_TintColor` - Цвет в **Зеленом (G)** канале маски. 
* `B_TintColor` - Цвет в **Голубом (B)** канале маски. 
* PBR properties:
  * `MaskMap` - Маска с PBR свойствами, подробнее о ней можно узнать [тут](https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@13.1/manual/Mask-Map-and-Detail-Map.html). Так же на эту маску влияют множители описанные ниже.
  * `Metallic` - Множитель металлика материала.
  * `AmbientOcclusion` - Множитель AmbientOcclusion.
  * `Smoothness` - Множитель Smoothness.
* Emission:
  * `EmissionMask` - Маска эмиссии. Именно эта маска отвечает за то, как будет подсвечена текстура объекта.
  * `EmissionColorOverride` - Модификатор цвета свечения.
  * `EmissionPower` - Интенсивность свечения.
  * `EmissionIntensity` - Этот параметр управляется Kino. Вы можете использовать его для предпросмотра свечения. Его значения **не будут сохранены**.

> [!NOTE]
> Если вы хотите добавить зеркало заднего вида, то назовите его `mirror`, тогда Kino автоматически установит ему нужный материал.

### Добавление датчиков и индикаторов

Для создания доступны следующие датчики и индикаторы:

* `Arrow_Speed`
* `Arrow_Rpm`
* `Arrow_Boost`
* `Arrow_Dummy`
* `DigitalArrow_Speed`
* `DigitalArrow_Rpm`
* `DigitalArrow_Boost`
* `DigitalArrow_Dummy`
* `Text_Speed`
* `Text_Rpm`
* `Text_Boost`
* `Text_Gear`
* `Text_Odometer`
* `Text_Clock`
* `Canvas_Root`
* `Canvas_ImageSpeed`
* `Canvas_ImageRpm`
* `Canvas_ImageBoost`
* `Indicator_Left`
* `Indicator_Right`
* `Indicator_HandBrake`
* `Indicator_RunningLights`
* `Indicator_HighBeams`
* `Indicator_CheckEngine`
* `Indicator_Hazard`

> [!NOTE]
> Обратите внимание, датчики с приставками `Text` и `Canvas` можно создать только в редакторе `Unity`. 

Датчики с приставкой `Arrow` - это механические датчики со стрелкой, без дополнительной анимации. Они будут даже при **выключенном зажигании**. 

Датчики с приставкой `DigitalArrow` - электронные датчики со стрелкой. При включении зажигания у них будет запущена анимация "инициализации", когда стрелка дойдет от начала шкалы до конца, а после обратно. Эти датчики будут показывать значения только при **включенном зажигании**.

Датчики с приставкой `Text` - цифровые, им можно задать любые шрифты, а так же [формат отображения](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings). Эти датчики будут показывать значения только при **включенном зажигании**.

Датчики с приставкой `Canvas` - это 2D элементы с помощью которых предполагается создание цифровых дешбордов и экранов. Оди будут активны только при **включенном зажигании**.

Индикаторы с приставкой `Indicator` - это своего рода "лампочки", которые будут отображать активность того или иного состояния. Эти индикаторы будут отображать состояние только при **включенном зажигании**.

> [!IMPORTANT]
> Kino будет искать датчики и индикаторы **только** в объекте `kino_indicators`, который должен быть в **родительском объекте** интерьера.

### Нейминг датчиков

![parts_interior_structure](../Images/CarParts/Interior/parts_interior_structure.png)

Для того, что бы Kino расценивал объект интерьера как датчик или индикатор, его нужно правильно назвать.

**Абсолютно все** датчики и индикаторы должны иметь имена, начинающиеся на [оду из приставок](#добавление-датчиков-и-индикаторов).

Некоторые датчики **требуют** указания дополнительных значений в имени. Значения должны быть разделены символом подчеркивания `_`.

> [!NOTE]
> Обратите внимание, что стрелки на датчиках вращаются по оси `Z` в Unity (`Y` в Blender). Имейте это ввиду, когда будете создавать их.

Описание значений для датчиков: 
* `Arrow_*` и `DigitalArrow_*` должны содержать **4** дополнительных значения:
  * 1: Ось вращения (x, -x, y, -y, z, -z), ось по которой Kino будет вращать стрелку датчика
  * 2: Угол при котором стрелка указывает на **минимальное** значение (на пример 0 оборотов)
  * 3: Угол при котором стрелка указывает на **максимальное** значение
  * 4: **Максимальное** значение на циферблате, на пример 300 км\ч, 10к оборотов и т.д.
* `Canvas_Image***` должны содержать **один** дополнительный аргумент:
  * 1: **Максимальное** значение на циферблате
* `Text_*` может **опционально** содержать один аргумент с указанием [формата текста](https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings)

> [!IMPORTANT]
> Обратите внимание, что для датчиков скорости её нужно указывать в `КМ\Ч`. Даже если спидометр размечен в милях, конвертируйте его максимальное значение в километры и используйте его.

#### Создание датчиков Arrow и DigitalArrow

Назовите стрелку датчика `Arrow` или `DigitalArrow` и укажите дополнительные аргументы.
На пример: `Arrow_Speed_y_0_202_300` значит, что датчик будет показывать скорость с начальной точкой (0 км\ч) на **0** градусов и конечной точкой (**300** км\ч) на **202** градусах.

Стрелка может быть как 3D объектом с любым материалом, так и 2D объектом на `Canvas`, ограничений нет.

![parts_interior_arrow_speed](../Images/CarParts/Interior/parts_interior_arrow_speed.png)

Пример электронного датчика буста: `DigitalArrow_Boost_-z_-90_177_2` значит, что начальная точка находится на **-90** градусах, а конечная (**2** атм) на **177** градусах вращения.

![parts_interior_digital_arrow_boost](../Images/CarParts/Interior/parts_interior_digital_arrow_boost.png)

Как вы знаете, у нас в игре нет давления масла, температуры воды, вольтажа и прочих показателей. Но вы можете добавить "фейковые" датчики, которые будут анимированны, для полноты картины.

Для этого существует два вида датчиков: 
* `Arrow_Dummy` - Механический со стрелкой
* `DigitalArrow_Dummy` - Электронный со стрелкой

Обратите внимание, что нейминг этих датчиков аналогичен обычным `Arrow` и `DigitalArrow`, но **третий аргумент** отвечает не за максимальный показатель на шкале, а за **угол**, на который будет повернута стрелка при включении зажигания. 

![parts_interior_dummy_gauge](../Images/CarParts/Interior/parts_interior_dummy_gauge.png)

#### Создание датчиков Text

Для создания цифровых датчиков используйте приставку `Text`, затем укажите какое значение он будет отображать. А так опционально можно задать формат отображения текста.
Пример создания цифрового одометра: `Text_Odometer_D7`, **D7** означает что текст будет отображаться в формате `0000123`, то есть текст размером в 7 символов с нулями в начале.

![parts_interior_text_odometer](../Images/CarParts/Interior/parts_interior_text_odometer.png)

Пример датчика оборотов: `Text_Rpm`

![parts_interior_text_rpm](../Images/CarParts/Interior/parts_interior_text_rpm.png)

> [!IMPORTANT]
> Обратите внимание, что для создания датчиков `Text_*` необходимо добавить компонент `TextMeshPro - Text` для 3D объектов или `TextMeshPro - Text (UI)` для Canvas.

![parts_interior_text_tmpro_component_add](../Images/CarParts/Interior/parts_interior_text_tmpro_component_add.png)

Вы можете настроить компонент текста как угодно, задать шрифт, форматирование, цвет. Ограничений нет.

![parts_interior_text_tmpro_setup](../Images/CarParts/Interior/parts_interior_text_tmpro_setup.png)

#### Создание индикаторов Indicator

Индикаторы могут быть **двух** видов:
* Emissive объекты с материалом `CarEmissiveIndicator` - это 3D объекты, которые будут подсвечиваться при активации
* Объекты с компонентом `Image` на **Canvas** - 2D изображения/иконки на Canvas

Пример создания 3D объёкта `Indicator_Right` - правый поворотник

![parts_interior_indicator_right](../Images/CarParts/Interior/parts_interior_indicator_right.png)

Для того что бы индикатор определился в Kino ему нужно задать материал с шейдером `CarEmissiveIndicator` и настроить его.

![parts_interior_indicator_right_material](../Images/CarParts/Interior/parts_interior_indicator_right_material.png)

Шейдер `CarEmissiveIndicator` является несколько упрощенной версией щейдера `CarInterior` с аналогичными параметрами.

> [!IMPORTANT]
> Обратите внимание, что для каждого индикатора нужно создавать свой отдельный материал.

![parts_interior_indicator_separate_materials](../Images/CarParts/Interior/parts_interior_indicator_separate_materials.png)

Пример создания 2D индикатора `Indicator_RIght` - правый поворотник на Canvas

![parts_interior_indicator_right_canvas](../Images/CarParts/Interior/parts_interior_indicator_right_canvas.png)

Для работы 2D индикаторы **обязательно** должны быть дочерними объектами объекта `Canvas_Root`.

Так же объекты индикаторов должны содержать компонент `Image`, который вы можете настроить как угодно.

![parts_interior_indicator_image](../Images/CarParts/Interior/parts_interior_indicator_image.png)

#### Создание Canvas индикаторов

Можно выделить два вида элементов группы `Canvas`:
* `Canvas_Root` - Это элемент-контейнер, своего рода "экран", на котором будут отображаться все 2D элементы. Элементов Canvas_Root может быть неограниченное количество.
* `Canvas_Image***` - 2D элемент с компонентом `Image` и типом отображения `Filled`. С помощью этих элементов, а так же дополнительных изображений и текста можно создавать комплексные цифровые приборные панели и экраны.

> [!IMPORTANT]
> При создании `Canvas_Root` обязательно установите ему слой `Default`, что бы он корректно отображался в гараже.

Все элементы с приставкой `Canvas_Image***` должны находится в объекте с именем `Canvas_Root`, который в свою очередь, должен содержать компонент `Canvas`.

![parts_interior_canvas_root_hierarchy](../Images/CarParts/Interior/parts_interior_canvas_root_hierarchy.png)

Так же выберете в поле `Render Mode` вариант `World Space`, что бы canvas корректно отображался.

![parts_interior_canvas_root](../Images/CarParts/Interior/parts_interior_canvas_root.png)

У всех элементов `Canvas_Image***` должен быть дополнительный аргумент - максимальное значение на шкале. На пример 10к оборотов для тахометра размеченного до 10к оборотов.

Пример создания 2D датчика оборотов `Canvas_ImageRpm_10000`

![parts_interior_canvas_image_rpm](../Images/CarParts/Interior/parts_interior_canvas_image_rpm.png)

Обратите внимание, что датчик оборотов `Canvas_ImageRpm` является подобъектом `Canvas_Root`.